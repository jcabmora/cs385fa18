
*******************************************
Lab No. 5: Horizontal Scalability and State
*******************************************

In this lab we are going to evaluate the implications for scalabitly when applications store data locally. 


Part 1: Setup a Kubernetes Cluster
==================================

#. Provision a Kubernetes cluster by following the steps from :ref:`Part 1 of Lab No. 3.<lab03-part1>`. Name the virtual machine  **lab05** and name your Kubernetes Cluster **lab05cluster**
   Make sure that you test the kubernetes cluster by deploying a test pod. (Any image is fine, as long as it lets you  confirm that the Kubernetes cluster is running.

#. On lab05 install `make`:

    .. parsed-literal::
        > sudo apt-get install make

Part 2: Testing an authorization service
========================================

For this part of the lab, you will download an update version of minibank that implements two different authentication schemas: cookie based and token based.


#. Download the update minibank source from https://github.com/jcabmora/minibank/tree/week6/week6

#. Build and run the images locally on ``lab05``:

    .. parsed-literal::
        > curl make run-images

#. Verify that there are two docker images running,  ``minibank`` and ``mysql``.

#. Test that the service works by registering a user:

    .. parsed-literal:: 
        > curl localhost/api/account/register -d '{"username": "john", "password": "john123456"}'
        Successfully registered account


The new version of minibank exposes two new REST API endpoints:

* **/api/account/login**: authenticates username/password credentials. If the authentication succeeds, generates session data internally and returns an empty ``200`` response with a ``sessionid`` cookie. For example, the following command:

    .. parsed-literal:: 
        > curl -c cookies.txt localhost/api/account login -d '{"username": "john", "password": "john123456"}'

When the previous command is run, it will store cookie information in a file called ``cookies.txt``. Once you open that file you should verify that it has been populated:

    .. parsed-literal::
        > cat cookies.txt
        # Netscape HTTP Cookie File
        # https://curl.haxx.se/docs/http-cookies.html
        # This file was generated by libcurl! Edit at your own risk.

        localhost       FALSE   /api/account/   FALSE   0       sessionid       9de2b793-c6aa-44f4-8e06-9b8525cacbd1


* **/api/account/token**:  also authenticates username/password credentials. If the authentication succeeds, then it returns a JSON payload that contains a JSON Web Token that can be used for token authorization.

    .. parsed-literal::
        > curl -X POST localhost:8080/api/account/token -d '{"username": "john", "password": "john123456"}'
        {"token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1Mzg4NDM2NzMsInVzZXJuYW1lIjoicmFtb24ifQ.QUQjgByqzclFM-GQ_tqvQogiwIVLUpI-Iu6SjLCRAMw"}


* **/api/account/sessions**: returns a list of the sessions that are associated with an authenticated user. Users need to provide either cookie or token proof of authentication. For example, to execute this using cookies: 

    .. parsed-literal::
        > curl -b cookies.txt localhost:8080/api/account/sessions
        {"sessions":["9bf4a24c-71bc-42de-8432-68bfbdd941d9","9de2b793-c6aa-44f4-8e06-9b8525cacbd1"]}

of if you prefer to use a token:

    .. parsed-literal::
        > curl  -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1Mzg4NDM2NzMsInVzZXJuYW1lIjoicmFtb24ifQ.QUQjgByqzclFM-GQ_tqvQogiwIVLUpI-Iu6SjLCRAMw" localhost:8080/api/account/sessions




In this part of the lab you will deploy a very simple application that exposes a REST API with two endpoints:




- ``POST /fibonacci``: takes a json payload with a single element ``fibonacci_number`` of type int. Example:

    .. parsed-literal::
        > curl -X POST -H 'Content-Type: application/json' http://<IP_ADDR>:8080/fibonacci -d '{"fibonacci_number": 27}'
        {"fibonacci_number":27,"value":196418}

- ``GET /status``: returns internal state maintaned by the application (the size of a fibonacci number internal cache and a request counter)

    .. parsed-literal::
        > curl http://<IP_ADDR>:8080/status
        {"cache_length":1001,"request_count":2847}


The application is hardcoded to listen in port 8080. The source of the application is the following:

    .. literalinclude:: support_files/main.go

#. Create a docker image to run this application. Tag the image as ``gcr.io/<YOUR_GCP_PROJECT>/fibonacci:latest`` (replace your GCP project ID accordingly).  Test your image locally, and once you have confirmed that it works, push the image to the Google Cloud Container Registry.

#. Create a Kubernetes Service that exposes the application using a **Load Balancer** type. (Same procedure as items 1 and 2 in :ref:`Part 4 of Lab 3<lab03-part4>`). 

#. Wait until your service has been assigned an external IP Address. Once this is done, test your service before proceeding to the next section of the Lab. Do not scale your service since for next lab section, we need it to be running with only one replica.


Part 3: Measuring your instance performance
===========================================

To measure the performance of our web service we are going to use *ApacheBench*, also known as ``ab``, a popular benchmarking tool (https://httpd.apache.org/docs/2.4/programs/ab.html). 

#. SSH into the **lab04** instance. Run the following sequence of commands to install ``ab``:

    .. parsed-literal::
        > sudo apt-get update
        > sudo apt-get install -y apache2-utils build-essential

#. Since we are going to run our benchmarks with high concurrency levels, we need to increment the maximum number of open files that the kernel will allow.  Run the following command (Note: this is not a persistent change, and you will need to run this command again if you log out or reboot **lab04**)

   .. parsed-literal::
        >> ulimit -n 25000

#. Create a file called ``payload.json`` with a single line with ``{"fibonacci_number": 20}`` as its content:

    .. parsed-literal::
        > echo '{"fibonacci_number": 20}' > payload.json

#. Run a test ``ab`` benchmark to verify installation (replace ``<SERVICE_EXT_IP>`` with the external IP address of the Kubernetes service that you deployed in the previous section):

    .. parsed-literal::
        >  ab -p payload.json -T application/json -m POST -n 100 -s 100 -r http://<SERVICE_EXT_IP>:8080/fibonacci

   In the previous command, ``ab`` executed 100 requests (which is indicated by the ``-n`` argument) with a **concurrency level of 1** (which is the default value when the ``-c`` option is ommitted.).



#. In the ``ab`` benchmark that we run before, the ``-c`` option is used to simulate a given number of simultaneous connections (10 in that case),  the ``-n`` option is used to determine the number of requests to issue(10 requests in the example). Experiment running ``ab`` with different concurrency levels, in batches of 10000 requests.  Fill out the following table:

.. cssclass:: minitable

=============  ==========  ==========================  ===============  =============
Concurrency    Requests    Requests per second (mean)  Longest request  98 percentile
=============  ==========  ==========================  ===============  =============
50             10000			
100            10000
500            10000
1000           10000
2000           10000
5000           20000
10000          30000
15000          45000
=============  ==========  ==========================  ===============  =============

.. note::

    Apparently ``ab`` has a bug where if one of the requests times out, it exits with the message ``apr_pollset_poll: The timeout specified has expired (70007)``, instead of recording it as a failed request. If you run into this problem try to run the test again.


.. admonition:: What to turn in
    :class: worksheet
    
    Answer the following questions. Assume that you are not allowed to modify your current Kubernets infrastructure (i.e. you are not allowed to add more worker nodes to your Kubernetes cluster):

    #. Using the previous observations, determine approximately at which concurrency level the performance of the fibonacci service begins to degrade.
   
    #. Repeat the measurements made with ``ab`` when the service is scaled to 3, 6, 9 and 12 replicas. Save the data in a comma delimited file (csv) with the following columns: ``replicas``, ``concurrency``, ``requests_per_second``, ``longest_request``, ``98_percentile``. You will need to upload this file during your Lab submission.

    #. Did you get a noticeable improvement between 9 and 12 replicas? Explain this behavior.

    #. What is the maximum throughput your service can provide?  What is the maximum concurrency that you can support, while maintaining maximum throughput? How many replicas (approximately) do you need to support that concurrency level and throughput?

    #. Suppose we expect our service to have a maximum number of 2000 concurrent users.
       We have a Service Level Agreement with our customers in which we guarantee a maximum response time up to 1.5 seconds, with a mean response of less than 300 milliseconds, with requests 98% of the time less than 600 ms.  Can we fulfill those requirements? If so, how many replicas will be needed?
